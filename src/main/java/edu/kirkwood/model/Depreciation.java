package edu.kirkwood.model;

import java.util.Objects;

public class Depreciation {
    private Fraction assetCost;
    private Fraction salvageValue;
    private int usefulLife; // useful life is typically an integer number of years

    /**
     *
     * @param assetCost The initial cost of the asset.
     * @param salvageValue The estimated residual value of an asset at the end of its useful life.
     * @param usefulLife The estimated number of years an asset is expected to be useful.
     *
     */
    public Depreciation(double assetCost, double salvageValue, int usefulLife) {
        this.assetCost = new Fraction((int) assetCost, 1);
        this.salvageValue = new Fraction((int) salvageValue, 1);
        this.usefulLife = usefulLife;
        if (usefulLife <= 0) {
            throw new IllegalArgumentException("Useful life must be a positive number");
        }
        if (assetCost < salvageValue) {
            throw new IllegalArgumentException("Asset cost must be greater than salvage value");
        }
    }

    /**
     *
     * @return
     */
    public Fraction getAssetCost() {
        return assetCost;
    }

    public void setAssetCost(double assetCost) {
        Fraction newCost = new Fraction((int) assetCost, 1);
        if (newCost.compareTo(this.salvageValue) < 0) {
            throw new IllegalArgumentException("New asset cost cannot be less than salvage value.");
        }
        this.assetCost = newCost;
    }

    public Fraction getSalvageValue() {
        return salvageValue;
    }

    /**
     *
     * @param salvageValue The new salvage value.
     */
    public void setSalvageValue(double salvageValue) {
        Fraction newSalvage = new Fraction((int)salvageValue, 1);
        if (newSalvage.compareTo(this.assetCost) > 0) {
            throw new IllegalArgumentException("New salvage value cannot be greater than asset cost.");
        }
        this.salvageValue = newSalvage;
    }

    /**
     * Gets the useful life in years
     * @return
     */
    public int getUsefulLife() {
        return usefulLife;
    }

    public void setUsefulLife(int usefulLife) {
        if (usefulLife <= 0) {
            throw new IllegalArgumentException("Useful life must be a positive number.");
        }
        this.usefulLife = usefulLife;
    }

    /**
     * I got this from this link https://www.calculator.net/depreciation-calculator.html
     * Calculates the annual depreciation using the straight-line method.
     * Formula: (Asset Cost - Salvage Value) / Useful Life
     * @return A Fraction representing the annual depreciation.
     */
    public Fraction calculateAnnualDepreciation() {
        // (Asset Cost - Salvage Value)
        Fraction depreciableBase = this.assetCost.subtract(this.salvageValue);
        // Divide by Useful life
        Fraction lifeAsFraction = new Fraction(usefulLife, 1);
        return depreciableBase.divide(lifeAsFraction);
    }

    /**
     * Code generated by Ai
     * Calculates the accumulated depreciation up to a specific number of years.
     * Formula: Annual Depreciation * Number of Years
     * @param years The number of years for which to calculate accumulated depreciation.
     * @return A Fraction representing the accumulated depreciation.
     */
    public Fraction calculateAccumulatedDepreciation(int years) {
        if (years < 0) {
            throw new IllegalArgumentException("Number of years cannot be negative.");
        }
        if (years > usefulLife) {
            throw new IllegalArgumentException("Number of years for accumulated depreciation cannot exceed useful life.");
        }
        Fraction annualDepreciation = calculateAnnualDepreciation();
        return annualDepreciation.multiply(new Fraction(years, 1));
    }

    /**
     *
     * @param years The number of years passed to calculate accumulated depreciation for.
     * @return A Fraction representing the item value.
     */
    public Fraction calculateItemValue(int years) {
        Fraction accumulatedDepreciation = calculateAccumulatedDepreciation(years);
        Fraction itemValue = this.assetCost.subtract(accumulatedDepreciation);
        // item value should not drop below salvage value
        if (itemValue.compareTo(this.salvageValue) < 0) {
            return this.salvageValue; // Ensures item value doesn't go below salvage
        }
        return itemValue;
    }
    @Override
    public boolean equals(Object o) {
        if (o == null || getClass() != o.getClass()) return false;
        Depreciation that = (Depreciation) o;
        return usefulLife == that.usefulLife && Objects.equals(assetCost, that.assetCost) && Objects.equals(salvageValue, that.salvageValue);
    }

    @Override
    public int hashCode() {
        return Objects.hash(assetCost, salvageValue, usefulLife);
    }

    @Override
    public String toString() {
        return "Depreciation{" +
                "assetCost=" + assetCost +
                ", salvageValue=" + salvageValue +
                ", usefulLife=" + usefulLife +
                '}';
    }
}
